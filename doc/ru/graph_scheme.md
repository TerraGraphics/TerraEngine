# Graph Scheme (GScheme)

## Обзор

GScheme представляет собой ориентированный ациклический граф `gs::Graph`, состоящий из нескольких связанных узлов.

Узлы графа `gs::Node` могут иметь разную конфигурацию и поведение, которые определяются реальным классом `compute class` описанным соответствующим образом. Метаданные конфигурации содержатся в `gs::Class` и заполняются на основании данных, которые предоставляет библиотека [cpgf](https://github.com/cpgf/cpgf). В число этих данных входят: указатели на функции задающие входные данные и встроенные переменные, необходимые `compute` классу для вычислений, а так же на функции возвращающие результат. Так же доступна информация о типах входов, встроенных переменных и выходов.

Каждый узел графа `gs::Node` представляет собой инстанс `compute` класса, плюс информация о связях входов и выходов (`gs::Pin`) с другими узлами.

Каждый `gs::Pin` связан с набором функций, которые используются для задания\получения значений от `compute` класса. Каждое значение может иметь тип из ограниченного набора `gs::TypeId`.

## Типы (gs::TypeId)

Каждый `gs::Pin` связан с типом данных, при этом количество возможных типов ограничено, а так же на каждый вид пина накладываются дополнительные ограничения.

Типы можно разбить на следующие категории:

- Стандартные [`Int8`, `Uint8`, `Int16`, `Uint16`, `Int32`, `Uint32`, `Int64`, `Uint64`, `Float`, `Double`].
- Вектора [`Vector2f`, `Vector3f`, `Vector4f`] - соответственно вектора из 2-х, 3-х и 4-х элементов типа float.
- Генераторы [`Generator2d`, `Generator3d`] - это структуры, которые генерируют бесконечные 2-х и 3-х мерные наборы значений типа double.
- Универсальный тип [`gs::UniversalType`] - это `std::variant`, который ограничен типами `Float`, `Vector2f`, `Vector3f`, `Vector4f`, `Generator2d`, `Generator3d`.
- `UniversalType`, тип которого известен [`UniversalFloat`, `UniversalVector2f`, `UniversalVector3f`, `UniversalVector4f`, `UniversalGenerator2d`, `UniversalGenerator3d`] - в ряде случаев полезно знать какой конкретный тип сейчас имеет `UniversalType`. Этот набор можно назвать `конкретными универсальными типами` (`concrete universal types`).

Пины, которые соответствуют значениям, которыми параметризуют `compute class`, ограничены стандартными типами и векторами.

Пины, которые соответствуют входящим и исходящим значениям, ограниченны следующим набором: `Float`, вектора, генераторы, `UniversalType`. Именно этим объясняется почему `UniversalType` включает в себя только ограниченный набор типов - это типы, который доступны для входящих и исходящих знаний. Для удобства назовём эти типы (`Float`, вектора, генераторы) - `базовыми` (`basic types`).

Смысл введения `UniversalType` в том, что бы можно было писать `compute` сразу для всех базовых типов. Н-р можно написать такой класс, который умеет складывать любой базовый тип.

Отсюда возникает необходимость знать возможно ли конвертировать один базовый тип в другой и иметь собственно саму функцию конвертации. Для этого служат:

``` cpp
bool gs::CanConvert<To, From>;
bool gs::IsCanConvert<To, From>();
To ConvertTo(const From& value);
```

Н-р:

``` cpp
constexpr gs::CanConvert<Eigen::Vector2f, float> == true;
gs::IsCanConvert<Eigen::Vector2f, float>() == true;
Eigen::Vector2f ConvertTo(const float& value);
```

Эти выражения имеют смысл только для базовых типов, а для любых других, в том числе `UniversalType` всегда возвращают false (а функция конвертации не компилируется на данных, которые невозможно конвертировать).

Уровнем выше находится класс `TypesConvertStorage`. Он работает уже на уровне идентификаторов типов (`gs::TypeId`). И позволяет промерить возможно ли конвертировать один `gs::TypeId` в другой. А так же умеет возвращать функцию конвертации между этими типами. Так же класс умеет работать с расширенным набором типов и конвертировать:

- Из `базовогово` в `базовый`
- Из `базовогово` в `UniversalType`
- Из `конкретного универсального типа` в `базовый`
- Из `конкретного универсального типа` в `UniversalType`

Выбор именного этого набора преобразований объясняется тем, что в графе встречаются именно такие случаи.
